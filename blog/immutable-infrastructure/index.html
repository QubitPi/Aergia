<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">What Is Immutable Infrastructure | Aergia</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://qubitpi.github.io/aergia/blog/immutable-infrastructure"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="What Is Immutable Infrastructure | Aergia"><meta data-rh="true" name="description" content="In a traditional mutable server infrastructure, servers are continually updated and modified in place. Engineers and"><meta data-rh="true" property="og:description" content="In a traditional mutable server infrastructure, servers are continually updated and modified in place. Engineers and"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-08-30T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://www.digitalocean.com/community/tutorials/what-is-immutable-infrastructure,https://github.com/QubitPi"><meta data-rh="true" property="article:tag" content="Continuous Delivery"><link data-rh="true" rel="icon" href="/aergia/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://qubitpi.github.io/aergia/blog/immutable-infrastructure"><link data-rh="true" rel="alternate" href="https://qubitpi.github.io/aergia/blog/immutable-infrastructure" hreflang="en"><link data-rh="true" rel="alternate" href="https://qubitpi.github.io/aergia/blog/immutable-infrastructure" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/aergia/blog/rss.xml" title="Aergia RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/aergia/blog/atom.xml" title="Aergia Atom Feed"><link rel="stylesheet" href="/aergia/assets/css/styles.99c6e2a1.css">
<link rel="preload" href="/aergia/assets/js/runtime~main.f632bfca.js" as="script">
<link rel="preload" href="/aergia/assets/js/main.9ceff044.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/aergia/"><div class="navbar__logo"><img src="/aergia/img/logo.png" alt="Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/aergia/img/logo.png" alt="Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Aergia</b></a><a class="navbar__item navbar__link" href="/aergia/docs/intro">Recipes</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/aergia/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/QubitPi/aergia" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Enterprise IaC</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/iac-intro">Introduction to Infrastructure as Code (IaC)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/ruby">Ruby Essentials</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/jenkins-on-aws">Deploying Jenkins to AWS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/jenkins-troubleshooting">Jenkins Troubleshooting</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/nexus">Nexus 3 Repository Manager OSS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/nexus">Nexus 3 - Setting Up Docker Registry</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/continuous-delivery">Continuous Delivery</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/aergia/blog/immutable-infrastructure">What Is Immutable Infrastructure</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/deploying-vs-releasing">Deploying v.s. Releasing</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/docker-c-advisor">Docker cAdvisor</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/screwdriver">Open Sourcing Screwdriver - Yahoo&#x27;s Continuous Delivery Build System for Dynamic Infrastructure</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/openvpn">OpenVPN</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/aergia/blog/ssh-ascii-banner">Add Custom ASCII Banner Logo to SSH Login Screen</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">What Is Immutable Infrastructure</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-08-30T00:00:00.000Z" itemprop="datePublished">August 30, 2022</time> · <!-- -->10 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://www.digitalocean.com/community/tutorials/what-is-immutable-infrastructure" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/DigitalOcean_logo.svg/1024px-DigitalOcean_logo.svg.png" alt="Hazel Virdó"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://www.digitalocean.com/community/tutorials/what-is-immutable-infrastructure" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Hazel Virdó</span></a></div><small class="avatar__subtitle" itemprop="description">Senior Technical Writer</small></div></div></div><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/QubitPi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/16126939?v=4" alt="Jiaqi Liu"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/QubitPi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Jiaqi Liu</span></a></div><small class="avatar__subtitle" itemprop="description">Maintainer of Aergia</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>In a traditional mutable server infrastructure, servers are continually updated and modified in place. Engineers and
administrators working with this kind of infrastructure can SSH into their servers, upgrade or downgrade packages
manually, tweak configuration files on a server-by-server basis, and deploy new code directly onto existing servers. In
other words, these servers are mutable; they can be changed after they’re created. Infrastructure comprised of mutable
servers can itself be called mutable, traditional, or (disparagingly) artisanal.</p><p>An immutable infrastructure is another infrastructure paradigm in which servers are never modified after they&#x27;re
deployed. If something needs to be updated, fixed, or modified in any way, new servers built from a common image with
the appropriate changes are provisioned to replace the old ones. After they’re validated, they’re put into use and the
old ones are decommissioned.</p><p>The benefits of an immutable infrastructure include more consistency and reliability in your infrastructure and a
simpler, more predictable deployment process. It mitigates or entirely prevents issues that are common in mutable
infrastructures, like configuration drift and <a href="https://martinfowler.com/bliki/SnowflakeServer.html" target="_blank" rel="noopener noreferrer">snowflake servers</a>.
However, using it efficiently often includes comprehensive deployment automation, fast server provisioning in a cloud
computing environment, and solutions for handling stateful or ephemeral data like logs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="differences-between-mutable-and-immutable-infrastructure">Differences Between Mutable and Immutable Infrastructure<a class="hash-link" href="#differences-between-mutable-and-immutable-infrastructure" title="Direct link to heading">​</a></h2><p>The most fundamental difference between mutable and immutable infrastructure is in their central policy: the components
of the former are designed to be changed after deployment; the components of the latter are designed to remain unchanged
and ultimately be replaced.</p><p>Conceptually speaking, the two kinds of infrastructure vary greatly in their approach to how servers should be treated
(e.g. created, maintained, updated, destroyed). This is commonly illustrated with a &quot;pets versus cattle&quot; analogy.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Pets v.s. Cattle</div><div class="admonitionContent_S0QG"><p>The servers in traditional mutable infrastructures were irreplaceable, unique systems that had to be kept running at all
times. In this way, they were like <strong>pets</strong>: one of a kind, inimitable, and tended to by hand. Losing one could be
devastating. The servers in immutable infrastructures, on the other hand, are disposable and easy to replicate or scale
with automated tools. In this way, they&#x27;re like <strong>cattle</strong>: one of many in a herd where no individual is unique or
indispensable.</p><p>To quote <a href="http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/" target="_blank" rel="noopener noreferrer">Randy Bias</a>, who first applied
the pets vs. cattle analogy to cloud computing:</p><blockquote><p>In the old way of doing things, we treat our servers like pets, for example Bob the mail server. If Bob goes down,
it&#x27;s all hands on deck. The CEO can’t get his email and it’s the end of the world. In the new way, servers are
numbered, like cattle in a herd. For example, www001 to www100. When one server goes down, it&#x27;s taken out back, shot,
and replaced on the line.</p></blockquote><p>Another similar way of illustrating the implications of the difference between how servers are treated is with the
concepts of snowflake servers and phoenix servers.</p><p><a href="https://martinfowler.com/bliki/SnowflakeServer.html" target="_blank" rel="noopener noreferrer"><strong>Snowflake servers</strong></a> are similar to pets. They are servers that
are managed by hand, frequently updated and tweaked in place, leading to a unique environment.
<a href="https://martinfowler.com/bliki/PhoenixServer.html" target="_blank" rel="noopener noreferrer"><strong>Phoenix servers</strong></a> are similar to cattle. They are servers that
are always built from scratch and are easy to recreate (or &quot;rise from the ashes&quot;) through automated procedures.</p></div></div><p>Practically speaking, mutable infrastructure is a much older infrastructure paradigm that predates the core
technologies, like virtualization and <a href="#embracing-the-cloud">cloud computing</a>, that make immutable infrastructures
possible and practical. Knowing this history helps contextualize the conceptual differences between the two and the
implications of using one or the other in modern day infrastructure.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="embracing-the-cloud">Embracing the Cloud<a class="hash-link" href="#embracing-the-cloud" title="Direct link to heading">​</a></h2><p>Before virtualization and cloud computing became possible and widely available, server infrastructure was centered
around physical servers. These physical servers were expensive and time-consuming to create; the initial setup could
take days or weeks because of how long it took to order new hardware, configure the machine, and then install it in a
<a href="https://en.wikipedia.org/wiki/Colocation_centre" target="_blank" rel="noopener noreferrer">colo</a> or similar location.</p><p>Mutable infrastructure has its origins here. Because the cost of replacing a server was so high, it was most practical
to keep using the servers you had running for as long as possible with as little downtime as possible. This meant there
were a lot of in place changes for regular deployments and updates, but also for ad-hoc fixes, tweaks, and patches when
something went wrong. The consequence of frequent manual changes is that servers can become hard to replicate, making
each one a unique and fragile component of the overall infrastructure.</p><p>The advent of virtualization and on-demand/cloud computing represented a turning point in server architecture. Virtual
servers were less expensive, even at scale, and they could be created and destroyed in minutes instead of days or weeks.
This made new deployment workflows and server management techniques possible for the first time, like using
configuration management or cloud APIs to provision new servers quickly, programmatically, and automatically. The speed
and low cost of creating new virtual servers is what makes the immutability principle practical.</p><p>Traditional mutable infrastructures originally developed when the use of physical servers dictated what was possible in
their management, and continued to develop as technology improved over time. The paradigm of modifying servers after
deployment is still common in modern day infrastructure. In contrast, immutable infrastructures were designed from the
start to rely on virtualization-based technologies for fast provisioning of architecture components, like cloud
computing&#x27;s virtual servers.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="advantages-of-immutable-infrastructure">Advantages of Immutable Infrastructure<a class="hash-link" href="#advantages-of-immutable-infrastructure" title="Direct link to heading">​</a></h2><p>To understand the advantages of immutable infrastructures, it’s necessary to contextualize the disadvantages of mutable
infrastructures.</p><p>Servers in mutable infrastructures can suffer from configuration drift, which is when undocumented, impromptu changes
cause servers&#x27; configurations to become increasingly divergent from each other and from the reviewed, approved, and
originally-deployed configuration. These increasingly snowflake-like servers are hard to reproduce and replace, making
things like scaling and recovering from issues difficult. Even replicating issues to debug them becomes challenging
because of the difficulty of creating a staging environment that matches the production environment.</p><p>With this in mind, the primary benefits of using an immutable infrastructure are deployment simplicity, reliability, and
consistency, all of which ultimately minimize or eliminate many common pain points and failure points.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="known-good-server-state-and-fewer-deployment-failures">Known-Good Server State and Fewer Deployment Failures<a class="hash-link" href="#known-good-server-state-and-fewer-deployment-failures" title="Direct link to heading">​</a></h3><p>All deployments in an immutable infrastructure are executed by provisioning new servers based on a validated and
version-controlled image. As a result, these deployments don’t depend on the previous state of a server, and
consequently can&#x27;t fail - or only partially complete - because of it.</p><p>When new servers are provisioned, they can be tested before being put into use. In addition, deployments become
<a href="https://en.wikipedia.org/wiki/Linearizability" target="_blank" rel="noopener noreferrer">atomic</a>: either they complete successfully or nothing changes.</p><p>This makes deploying much more reliable and also ensures that the state of every server in the infrastructure is always</p><p>known. Additionally, this process makes it easy to implement a <a href="/aergia/blog/continuous-delivery">blue-green deployment</a> or</p><p><a href="https://en.wikipedia.org/wiki/Rolling_release" target="_blank" rel="noopener noreferrer">rolling releases</a>, meaning no downtime.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="no-configuration-drift-or-snowflake-servers">No configuration Drift or Snowflake Servers<a class="hash-link" href="#no-configuration-drift-or-snowflake-servers" title="Direct link to heading">​</a></h3><p>All configuration changes in an immutable infrastructure are implemented by checking an updated image into version
control with documentation and using an automated, unified deployment process to deploy replacement servers with that
image. Shell access to the servers is sometimes completely restricted.</p><p>This prevents complicated or hard-to-reproduce setups by eliminating the risk of snowflake servers and configuration
drift. This also prevents situations where someone needs to modify a poorly-understood production server, which runs a
high risk of error and causing downtime or unintended behavior.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="consistent-staging-environments-and-easy-horizontal-scaling">Consistent Staging Environments and Easy Horizontal Scaling<a class="hash-link" href="#consistent-staging-environments-and-easy-horizontal-scaling" title="Direct link to heading">​</a></h3><p>Because all servers use the same creation process, there are no deployment edge cases. This prevents messy or
inconsistent staging environments by making it trivial to duplicate the production environment, and also simplifies
horizontal scaling by seamlessly allowing you to add more identical servers to your infrastructure.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="simple-rollback-and-recovery-processes">Simple Rollback and Recovery Processes<a class="hash-link" href="#simple-rollback-and-recovery-processes" title="Direct link to heading">​</a></h3><p>Using version control to keep image history also helps with handling production issues. The same process that is used to
deploy new images can also be used to roll back to older versions, adding additional resilience and reducing recovery
time when handling downtime.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="implementing-immutable-infrastructure">Implementing Immutable Infrastructure<a class="hash-link" href="#implementing-immutable-infrastructure" title="Direct link to heading">​</a></h2><p>Immutable infrastructure comes with some requirements and nuance in its implementation details, especially compared to
traditional mutable infrastructures.</p><p>It is technically possible to implement an immutable infrastructure independent of any automation, tooling, or software
design principles by simply adhering to the key principle of immutability. However, the components below (roughly in
priority order) are strongly recommended for practicality at scale:</p><ul><li><p><strong>Dedication from engineering and operations teams</strong> to collaborate and commit to the approach. For all the simplicity
of the end product, there are a lot of moving parts in an immutable infrastructure, and no one person will know all of
it. Additionally, some aspects of working within this infrastructure can be new or outside of people’s comfort zones,
like debugging or doing one-off tasks without shell access.</p></li><li><p><strong>Servers in a cloud computing environment</strong>, or another virtualized environment. The key here is to have isolated
instances with fast provisioning from custom images, as well as automated management for creation and destruction via
an API or similar.</p></li><li><p><strong>Full automation of the entire deployment pipeline</strong>, ideally including post-creation image validation. Setting up
this automation adds significantly to the upfront cost of implementing this infrastructure, but it is a one-time cost
which amortizes out quickly.</p></li><li><p><strong>A <a href="https://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank" rel="noopener noreferrer">service-oriented architecture</a></strong>, separating our
infrastructure into modular, logically discrete units that communicate over a network.</p></li><li><p><strong>A <a href="https://en.wikipedia.org/wiki/Service_statelessness_principle" target="_blank" rel="noopener noreferrer">stateless</a>, volatile application layer</strong> which
includes our immutable servers. Anything here can get destroyed and rebuilt quickly at any time (volatile) without any
loss of data (stateless).</p></li><li><p><strong>A persistent data layer</strong> that includes:</p><ul><li><strong>Centralized logging</strong> with additional details about a server&#x27;s deployment, like image identification via a version
or Git commit SHA. Because servers are disposable (and frequently disposed of) in this infrastructure, storing logs
and metrics externally allows debugging <em>even when shell access is restricted</em> or after a server has been destroyed.</li><li><strong>External data stores</strong> for databases and any other stateful or ephemeral data. We will never rely on local storage
when the servers are volatile, so we need to store that data elsewhere.</li></ul></li></ul><p>There are many different ways to implement each of these components. CI/CD tools can be a good place to start for
deployment pipeline automation; <a href="https://github.com/Netflix/chaosmonkey" target="_blank" rel="noopener noreferrer">Netflix&#x27;s Chaos Monkey</a>, which randomly kills
servers in your production environment, is a real trial by fire for your final setup.</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/aergia/blog/tags/continuous-delivery">Continuous Delivery</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/QubitPi/aergia/tree/gh-pages/blog/2022-08-30-immutable-infrastructure/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/aergia/blog/continuous-delivery"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Continuous Delivery</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/aergia/blog/deploying-vs-releasing"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Deploying v.s. Releasing</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#differences-between-mutable-and-immutable-infrastructure" class="table-of-contents__link toc-highlight">Differences Between Mutable and Immutable Infrastructure</a></li><li><a href="#embracing-the-cloud" class="table-of-contents__link toc-highlight">Embracing the Cloud</a></li><li><a href="#advantages-of-immutable-infrastructure" class="table-of-contents__link toc-highlight">Advantages of Immutable Infrastructure</a><ul><li><a href="#known-good-server-state-and-fewer-deployment-failures" class="table-of-contents__link toc-highlight">Known-Good Server State and Fewer Deployment Failures</a></li><li><a href="#no-configuration-drift-or-snowflake-servers" class="table-of-contents__link toc-highlight">No configuration Drift or Snowflake Servers</a></li><li><a href="#consistent-staging-environments-and-easy-horizontal-scaling" class="table-of-contents__link toc-highlight">Consistent Staging Environments and Easy Horizontal Scaling</a></li><li><a href="#simple-rollback-and-recovery-processes" class="table-of-contents__link toc-highlight">Simple Rollback and Recovery Processes</a></li></ul></li><li><a href="#implementing-immutable-infrastructure" class="table-of-contents__link toc-highlight">Implementing Immutable Infrastructure</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/aergia/docs/category/recipes">Recipes</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/aergia" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/aergia/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/QubitPi/aergia" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Jiaqi Liu. Built with Docusaurus.</div></div></div></footer></div>
<script src="/aergia/assets/js/runtime~main.f632bfca.js"></script>
<script src="/aergia/assets/js/main.9ceff044.js"></script>
</body>
</html>