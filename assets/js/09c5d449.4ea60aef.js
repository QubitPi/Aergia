"use strict";(self.webpackChunkaergia=self.webpackChunkaergia||[]).push([[5474],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=u(n),p=r,h=m["".concat(l,".").concat(p)]||m[p]||d[p]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7087:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={slug:"immutable-infrastructure",title:"What Is Immutable Infrastructure",authors:["hazel","jiaqi"],tags:["Continuous Delivery"]},o=void 0,s={permalink:"/aergia/blog/immutable-infrastructure",editUrl:"https://github.com/QubitPi/aergia/tree/gh-pages/blog/2022-08-30-immutable-infrastructure/index.md",source:"@site/blog/2022-08-30-immutable-infrastructure/index.md",title:"What Is Immutable Infrastructure",description:"In a traditional mutable server infrastructure, servers are continually updated and modified in place. Engineers and",date:"2022-08-30T00:00:00.000Z",formattedDate:"August 30, 2022",tags:[{label:"Continuous Delivery",permalink:"/aergia/blog/tags/continuous-delivery"}],readingTime:9.135,hasTruncateMarker:!0,authors:[{name:"Hazel Vird\xf3",title:"Senior Technical Writer",url:"https://www.digitalocean.com/community/tutorials/what-is-immutable-infrastructure",imageURL:"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/DigitalOcean_logo.svg/1024px-DigitalOcean_logo.svg.png",key:"hazel"},{name:"Jiaqi Liu",title:"Maintainer of Aergia",url:"https://github.com/QubitPi",imageURL:"https://avatars.githubusercontent.com/u/16126939?v=4",key:"jiaqi"}],frontMatter:{slug:"immutable-infrastructure",title:"What Is Immutable Infrastructure",authors:["hazel","jiaqi"],tags:["Continuous Delivery"]},prevItem:{title:"Continuous Delivery",permalink:"/aergia/blog/continuous-delivery"},nextItem:{title:"Deploying v.s. Releasing",permalink:"/aergia/blog/deploying-vs-releasing"}},l={authorsImageUrls:[void 0,void 0]},u=[{value:"Differences Between Mutable and Immutable Infrastructure",id:"differences-between-mutable-and-immutable-infrastructure",level:2},{value:"Embracing the Cloud",id:"embracing-the-cloud",level:2},{value:"Advantages of Immutable Infrastructure",id:"advantages-of-immutable-infrastructure",level:2},{value:"Known-Good Server State and Fewer Deployment Failures",id:"known-good-server-state-and-fewer-deployment-failures",level:3},{value:"No configuration Drift or Snowflake Servers",id:"no-configuration-drift-or-snowflake-servers",level:3},{value:"Consistent Staging Environments and Easy Horizontal Scaling",id:"consistent-staging-environments-and-easy-horizontal-scaling",level:3},{value:"Simple Rollback and Recovery Processes",id:"simple-rollback-and-recovery-processes",level:3},{value:"Implementing Immutable Infrastructure",id:"implementing-immutable-infrastructure",level:2}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In a traditional mutable server infrastructure, servers are continually updated and modified in place. Engineers and\nadministrators working with this kind of infrastructure can SSH into their servers, upgrade or downgrade packages\nmanually, tweak configuration files on a server-by-server basis, and deploy new code directly onto existing servers. In\nother words, these servers are mutable; they can be changed after they\u2019re created. Infrastructure comprised of mutable\nservers can itself be called mutable, traditional, or (disparagingly) artisanal."),(0,r.kt)("p",null,"An immutable infrastructure is another infrastructure paradigm in which servers are never modified after they're\ndeployed. If something needs to be updated, fixed, or modified in any way, new servers built from a common image with\nthe appropriate changes are provisioned to replace the old ones. After they\u2019re validated, they\u2019re put into use and the\nold ones are decommissioned."),(0,r.kt)("p",null,"The benefits of an immutable infrastructure include more consistency and reliability in your infrastructure and a\nsimpler, more predictable deployment process. It mitigates or entirely prevents issues that are common in mutable\ninfrastructures, like configuration drift and ",(0,r.kt)("a",{parentName:"p",href:"https://martinfowler.com/bliki/SnowflakeServer.html"},"snowflake servers"),".\nHowever, using it efficiently often includes comprehensive deployment automation, fast server provisioning in a cloud\ncomputing environment, and solutions for handling stateful or ephemeral data like logs."),(0,r.kt)("h2",{id:"differences-between-mutable-and-immutable-infrastructure"},"Differences Between Mutable and Immutable Infrastructure"),(0,r.kt)("p",null,"The most fundamental difference between mutable and immutable infrastructure is in their central policy: the components\nof the former are designed to be changed after deployment; the components of the latter are designed to remain unchanged\nand ultimately be replaced."),(0,r.kt)("p",null,'Conceptually speaking, the two kinds of infrastructure vary greatly in their approach to how servers should be treated\n(e.g. created, maintained, updated, destroyed). This is commonly illustrated with a "pets versus cattle" analogy.'),(0,r.kt)("admonition",{title:"Pets v.s. Cattle",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The servers in traditional mutable infrastructures were irreplaceable, unique systems that had to be kept running at all\ntimes. In this way, they were like ",(0,r.kt)("strong",{parentName:"p"},"pets"),": one of a kind, inimitable, and tended to by hand. Losing one could be\ndevastating. The servers in immutable infrastructures, on the other hand, are disposable and easy to replicate or scale\nwith automated tools. In this way, they're like ",(0,r.kt)("strong",{parentName:"p"},"cattle"),": one of many in a herd where no individual is unique or\nindispensable."),(0,r.kt)("p",{parentName:"admonition"},"To quote ",(0,r.kt)("a",{parentName:"p",href:"http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/"},"Randy Bias"),", who first applied\nthe pets vs. cattle analogy to cloud computing:"),(0,r.kt)("blockquote",{parentName:"admonition"},(0,r.kt)("p",{parentName:"blockquote"},"In the old way of doing things, we treat our servers like pets, for example Bob the mail server. If Bob goes down,\nit's all hands on deck. The CEO can\u2019t get his email and it\u2019s the end of the world. In the new way, servers are\nnumbered, like cattle in a herd. For example, www001 to www100. When one server goes down, it's taken out back, shot,\nand replaced on the line.")),(0,r.kt)("p",{parentName:"admonition"},"Another similar way of illustrating the implications of the difference between how servers are treated is with the\nconcepts of snowflake servers and phoenix servers."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://martinfowler.com/bliki/SnowflakeServer.html"},(0,r.kt)("strong",{parentName:"a"},"Snowflake servers"))," are similar to pets. They are servers that\nare managed by hand, frequently updated and tweaked in place, leading to a unique environment.\n",(0,r.kt)("a",{parentName:"p",href:"https://martinfowler.com/bliki/PhoenixServer.html"},(0,r.kt)("strong",{parentName:"a"},"Phoenix servers")),' are similar to cattle. They are servers that\nare always built from scratch and are easy to recreate (or "rise from the ashes") through automated procedures.')),(0,r.kt)("p",null,"Practically speaking, mutable infrastructure is a much older infrastructure paradigm that predates the core\ntechnologies, like virtualization and ",(0,r.kt)("a",{parentName:"p",href:"#embracing-the-cloud"},"cloud computing"),", that make immutable infrastructures\npossible and practical. Knowing this history helps contextualize the conceptual differences between the two and the\nimplications of using one or the other in modern day infrastructure."),(0,r.kt)("h2",{id:"embracing-the-cloud"},"Embracing the Cloud"),(0,r.kt)("p",null,"Before virtualization and cloud computing became possible and widely available, server infrastructure was centered\naround physical servers. These physical servers were expensive and time-consuming to create; the initial setup could\ntake days or weeks because of how long it took to order new hardware, configure the machine, and then install it in a\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Colocation_centre"},"colo")," or similar location."),(0,r.kt)("p",null,"Mutable infrastructure has its origins here. Because the cost of replacing a server was so high, it was most practical\nto keep using the servers you had running for as long as possible with as little downtime as possible. This meant there\nwere a lot of in place changes for regular deployments and updates, but also for ad-hoc fixes, tweaks, and patches when\nsomething went wrong. The consequence of frequent manual changes is that servers can become hard to replicate, making\neach one a unique and fragile component of the overall infrastructure."),(0,r.kt)("p",null,"The advent of virtualization and on-demand/cloud computing represented a turning point in server architecture. Virtual\nservers were less expensive, even at scale, and they could be created and destroyed in minutes instead of days or weeks.\nThis made new deployment workflows and server management techniques possible for the first time, like using\nconfiguration management or cloud APIs to provision new servers quickly, programmatically, and automatically. The speed\nand low cost of creating new virtual servers is what makes the immutability principle practical."),(0,r.kt)("p",null,"Traditional mutable infrastructures originally developed when the use of physical servers dictated what was possible in\ntheir management, and continued to develop as technology improved over time. The paradigm of modifying servers after\ndeployment is still common in modern day infrastructure. In contrast, immutable infrastructures were designed from the\nstart to rely on virtualization-based technologies for fast provisioning of architecture components, like cloud\ncomputing's virtual servers."),(0,r.kt)("h2",{id:"advantages-of-immutable-infrastructure"},"Advantages of Immutable Infrastructure"),(0,r.kt)("p",null,"To understand the advantages of immutable infrastructures, it\u2019s necessary to contextualize the disadvantages of mutable\ninfrastructures."),(0,r.kt)("p",null,"Servers in mutable infrastructures can suffer from configuration drift, which is when undocumented, impromptu changes\ncause servers' configurations to become increasingly divergent from each other and from the reviewed, approved, and\noriginally-deployed configuration. These increasingly snowflake-like servers are hard to reproduce and replace, making\nthings like scaling and recovering from issues difficult. Even replicating issues to debug them becomes challenging\nbecause of the difficulty of creating a staging environment that matches the production environment."),(0,r.kt)("p",null,"With this in mind, the primary benefits of using an immutable infrastructure are deployment simplicity, reliability, and\nconsistency, all of which ultimately minimize or eliminate many common pain points and failure points."),(0,r.kt)("h3",{id:"known-good-server-state-and-fewer-deployment-failures"},"Known-Good Server State and Fewer Deployment Failures"),(0,r.kt)("p",null,"All deployments in an immutable infrastructure are executed by provisioning new servers based on a validated and\nversion-controlled image. As a result, these deployments don\u2019t depend on the previous state of a server, and\nconsequently can't fail - or only partially complete - because of it."),(0,r.kt)("p",null,"When new servers are provisioned, they can be tested before being put into use. In addition, deployments become\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linearizability"},"atomic"),": either they complete successfully or nothing changes."),(0,r.kt)("p",null,"This makes deploying much more reliable and also ensures that the state of every server in the infrastructure is always"),(0,r.kt)("p",null,"known. Additionally, this process makes it easy to implement a ",(0,r.kt)("a",{parentName:"p",href:"continuous-delivery"},"blue-green deployment")," or"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Rolling_release"},"rolling releases"),", meaning no downtime."),(0,r.kt)("h3",{id:"no-configuration-drift-or-snowflake-servers"},"No configuration Drift or Snowflake Servers"),(0,r.kt)("p",null,"All configuration changes in an immutable infrastructure are implemented by checking an updated image into version\ncontrol with documentation and using an automated, unified deployment process to deploy replacement servers with that\nimage. Shell access to the servers is sometimes completely restricted."),(0,r.kt)("p",null,"This prevents complicated or hard-to-reproduce setups by eliminating the risk of snowflake servers and configuration\ndrift. This also prevents situations where someone needs to modify a poorly-understood production server, which runs a\nhigh risk of error and causing downtime or unintended behavior."),(0,r.kt)("h3",{id:"consistent-staging-environments-and-easy-horizontal-scaling"},"Consistent Staging Environments and Easy Horizontal Scaling"),(0,r.kt)("p",null,"Because all servers use the same creation process, there are no deployment edge cases. This prevents messy or\ninconsistent staging environments by making it trivial to duplicate the production environment, and also simplifies\nhorizontal scaling by seamlessly allowing you to add more identical servers to your infrastructure."),(0,r.kt)("h3",{id:"simple-rollback-and-recovery-processes"},"Simple Rollback and Recovery Processes"),(0,r.kt)("p",null,"Using version control to keep image history also helps with handling production issues. The same process that is used to\ndeploy new images can also be used to roll back to older versions, adding additional resilience and reducing recovery\ntime when handling downtime."),(0,r.kt)("h2",{id:"implementing-immutable-infrastructure"},"Implementing Immutable Infrastructure"),(0,r.kt)("p",null,"Immutable infrastructure comes with some requirements and nuance in its implementation details, especially compared to\ntraditional mutable infrastructures."),(0,r.kt)("p",null,"It is technically possible to implement an immutable infrastructure independent of any automation, tooling, or software\ndesign principles by simply adhering to the key principle of immutability. However, the components below (roughly in\npriority order) are strongly recommended for practicality at scale:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Dedication from engineering and operations teams")," to collaborate and commit to the approach. For all the simplicity\nof the end product, there are a lot of moving parts in an immutable infrastructure, and no one person will know all of\nit. Additionally, some aspects of working within this infrastructure can be new or outside of people\u2019s comfort zones,\nlike debugging or doing one-off tasks without shell access.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Servers in a cloud computing environment"),", or another virtualized environment. The key here is to have isolated\ninstances with fast provisioning from custom images, as well as automated management for creation and destruction via\nan API or similar.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Full automation of the entire deployment pipeline"),", ideally including post-creation image validation. Setting up\nthis automation adds significantly to the upfront cost of implementing this infrastructure, but it is a one-time cost\nwhich amortizes out quickly.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"A ",(0,r.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Service-oriented_architecture"},"service-oriented architecture")),", separating our\ninfrastructure into modular, logically discrete units that communicate over a network.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"A ",(0,r.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Service_statelessness_principle"},"stateless"),", volatile application layer")," which\nincludes our immutable servers. Anything here can get destroyed and rebuilt quickly at any time (volatile) without any\nloss of data (stateless).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"A persistent data layer")," that includes:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Centralized logging")," with additional details about a server's deployment, like image identification via a version\nor Git commit SHA. Because servers are disposable (and frequently disposed of) in this infrastructure, storing logs\nand metrics externally allows debugging ",(0,r.kt)("em",{parentName:"li"},"even when shell access is restricted")," or after a server has been destroyed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"External data stores")," for databases and any other stateful or ephemeral data. We will never rely on local storage\nwhen the servers are volatile, so we need to store that data elsewhere.")))),(0,r.kt)("p",null,"There are many different ways to implement each of these components. CI/CD tools can be a good place to start for\ndeployment pipeline automation; ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Netflix/chaosmonkey"},"Netflix's Chaos Monkey"),", which randomly kills\nservers in your production environment, is a real trial by fire for your final setup."))}d.isMDXComponent=!0}}]);